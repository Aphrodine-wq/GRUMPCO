/**
 * Cloud Provisioning Service
 * Full IaC generation for AWS, GCP, and Azure with Terraform/Pulumi support
 */

import logger from '../middleware/logger.js';

// ========== Types ==========

export type CloudProvider = 'aws' | 'gcp' | 'azure';
export type IaCTool = 'terraform' | 'pulumi';
export type ResourceType =
  | 'compute'
  | 'database'
  | 'storage'
  | 'serverless'
  | 'container'
  | 'cdn'
  | 'dns'
  | 'queue'
  | 'cache'
  | 'monitoring';

export interface CloudResource {
  type: ResourceType;
  name: string;
  provider: CloudProvider;
  config: DatabaseConfig | ComputeConfig | StorageConfig | ServerlessConfig | ContainerConfig | Record<string, unknown>;
}

export interface DatabaseConfig {
  engine: 'postgres' | 'mysql' | 'mongodb' | 'redis' | 'dynamodb' | 'firestore' | 'cosmosdb';
  size: 'small' | 'medium' | 'large';
  highAvailability?: boolean;
  backupRetentionDays?: number;
  version?: string;
}

export interface ComputeConfig {
  type: 'vm' | 'container' | 'serverless';
  size: 'small' | 'medium' | 'large' | 'xlarge';
  count?: number;
  os?: 'linux' | 'windows';
  autoScale?: {
    min: number;
    max: number;
    cpuTarget: number;
  };
}

export interface StorageConfig {
  type: 'object' | 'block' | 'file';
  size: number; // GB
  replication?: 'local' | 'regional' | 'global';
  public?: boolean;
}

export interface ServerlessConfig {
  runtime: 'nodejs20' | 'nodejs18' | 'python312' | 'python311' | 'go' | 'rust' | 'dotnet';
  memory: number; // MB
  timeout: number; // seconds
  triggers?: ('http' | 'schedule' | 'queue' | 'storage')[];
}

export interface ContainerConfig {
  image: string;
  cpu: number;
  memory: number; // MB
  replicas?: number;
  port?: number;
  envVars?: Record<string, string>;
}

export interface InfrastructureSpec {
  name: string;
  provider: CloudProvider;
  region: string;
  resources: CloudResource[];
  networking?: {
    vpcCidr?: string;
    publicSubnets?: boolean;
    privateSubnets?: boolean;
    natGateway?: boolean;
  };
  tags?: Record<string, string>;
}

export interface GeneratedIaC {
  tool: IaCTool;
  provider: CloudProvider;
  files: Array<{
    name: string;
    content: string;
  }>;
  commands: string[];
  estimatedCostPerMonth?: number;
}

// ========== Size Mappings ==========

const AWS_INSTANCE_SIZES: Record<string, string> = {
  small: 't3.small',
  medium: 't3.medium',
  large: 't3.large',
  xlarge: 't3.xlarge',
};

const GCP_MACHINE_TYPES: Record<string, string> = {
  small: 'e2-small',
  medium: 'e2-medium',
  large: 'e2-standard-2',
  xlarge: 'e2-standard-4',
};

const AZURE_VM_SIZES: Record<string, string> = {
  small: 'Standard_B1s',
  medium: 'Standard_B2s',
  large: 'Standard_B2ms',
  xlarge: 'Standard_B4ms',
};

const AWS_RDS_SIZES: Record<string, string> = {
  small: 'db.t3.micro',
  medium: 'db.t3.small',
  large: 'db.t3.medium',
};

const GCP_SQL_TIERS: Record<string, string> = {
  small: 'db-f1-micro',
  medium: 'db-g1-small',
  large: 'db-n1-standard-1',
};

const AZURE_SQL_SKUS: Record<string, string> = {
  small: 'Basic',
  medium: 'S0',
  large: 'S1',
};

// ========== Terraform Generators ==========

function generateTerraformAWS(spec: InfrastructureSpec): string {
  const lines: string[] = [
    '# Generated by G-Rump Cloud Provisioning',
    '# Terraform configuration for AWS',
    '',
    'terraform {',
    '  required_version = ">= 1.0"',
    '  required_providers {',
    '    aws = {',
    '      source  = "hashicorp/aws"',
    '      version = "~> 5.0"',
    '    }',
    '  }',
    '}',
    '',
    'provider "aws" {',
    `  region = "${spec.region}"`,
    '',
    '  default_tags {',
    '    tags = {',
    `      Project     = "${spec.name}"`,
    '      ManagedBy   = "terraform"',
    '      Environment = var.environment',
    ...Object.entries(spec.tags ?? {}).map(([k, v]) => `      ${k} = "${v}"`),
    '    }',
    '  }',
    '}',
    '',
    'variable "environment" {',
    '  description = "Environment name"',
    '  type        = string',
    '  default     = "production"',
    '}',
    '',
  ];

  // VPC if networking specified
  if (spec.networking) {
    lines.push(
      'module "vpc" {',
      '  source  = "terraform-aws-modules/vpc/aws"',
      '  version = "~> 5.0"',
      '',
      `  name = "${spec.name}-vpc"`,
      `  cidr = "${spec.networking.vpcCidr ?? '10.0.0.0/16'}"`,
      '',
      `  azs             = ["\${var.region}a", "\${var.region}b", "\${var.region}c"]`,
      '  private_subnets = ["10.0.1.0/24", "10.0.2.0/24", "10.0.3.0/24"]',
      '  public_subnets  = ["10.0.101.0/24", "10.0.102.0/24", "10.0.103.0/24"]',
      '',
      `  enable_nat_gateway = ${spec.networking.natGateway ?? false}`,
      '  single_nat_gateway = true',
      '}',
      ''
    );
  }

  // Generate resources
  for (const resource of spec.resources) {
    lines.push(...generateAWSResource(resource, spec.name));
  }

  return lines.join('\n');
}

function generateAWSResource(resource: CloudResource, projectName: string): string[] {
  const lines: string[] = [];
  const name = resource.name.replace(/[^a-zA-Z0-9]/g, '_');

  switch (resource.type) {
    case 'compute': {
      const config = resource.config as unknown as ComputeConfig;
      const instanceType = AWS_INSTANCE_SIZES[config.size] ?? 't3.medium';
      lines.push(
        `# Compute: ${resource.name}`,
        `resource "aws_instance" "${name}" {`,
        `  ami           = data.aws_ami.amazon_linux.id`,
        `  instance_type = "${instanceType}"`,
        '',
        '  tags = {',
        `    Name = "${projectName}-${resource.name}"`,
        '  }',
        '}',
        '',
        'data "aws_ami" "amazon_linux" {',
        '  most_recent = true',
        '  owners      = ["amazon"]',
        '',
        '  filter {',
        '    name   = "name"',
        '    values = ["amzn2-ami-hvm-*-x86_64-gp2"]',
        '  }',
        '}',
        ''
      );
      break;
    }
    case 'database': {
      const config = resource.config as unknown as DatabaseConfig;
      if (config.engine === 'dynamodb') {
        lines.push(
          `# DynamoDB: ${resource.name}`,
          `resource "aws_dynamodb_table" "${name}" {`,
          `  name           = "${projectName}-${resource.name}"`,
          '  billing_mode   = "PAY_PER_REQUEST"',
          '  hash_key       = "id"',
          '',
          '  attribute {',
          '    name = "id"',
          '    type = "S"',
          '  }',
          '',
          `  point_in_time_recovery {`,
          `    enabled = ${config.highAvailability ?? false}`,
          '  }',
          '}',
          ''
        );
      } else {
        const instanceClass = AWS_RDS_SIZES[config.size] ?? 'db.t3.small';
        lines.push(
          `# RDS ${config.engine}: ${resource.name}`,
          `resource "aws_db_instance" "${name}" {`,
          `  identifier     = "${projectName}-${resource.name}"`,
          `  engine         = "${config.engine}"`,
          `  engine_version = "${config.version ?? 'latest'}"`,
          `  instance_class = "${instanceClass}"`,
          '  allocated_storage = 20',
          '',
          `  db_name  = "${name}"`,
          '  username = var.db_username',
          '  password = var.db_password',
          '',
          `  multi_az               = ${config.highAvailability ?? false}`,
          `  backup_retention_period = ${config.backupRetentionDays ?? 7}`,
          '  skip_final_snapshot    = true',
          '}',
          '',
          'variable "db_username" {',
          '  type      = string',
          '  sensitive = true',
          '}',
          '',
          'variable "db_password" {',
          '  type      = string',
          '  sensitive = true',
          '}',
          ''
        );
      }
      break;
    }
    case 'storage': {
      const config = resource.config as unknown as StorageConfig;
      lines.push(
        `# S3 Bucket: ${resource.name}`,
        `resource "aws_s3_bucket" "${name}" {`,
        `  bucket = "${projectName}-${resource.name}-\${random_id.bucket_suffix.hex}"`,
        '}',
        '',
        `resource "aws_s3_bucket_versioning" "${name}_versioning" {`,
        `  bucket = aws_s3_bucket.${name}.id`,
        '  versioning_configuration {',
        '    status = "Enabled"',
        '  }',
        '}',
        ''
      );
      if (!config.public) {
        lines.push(
          `resource "aws_s3_bucket_public_access_block" "${name}_public" {`,
          `  bucket = aws_s3_bucket.${name}.id`,
          '',
          '  block_public_acls       = true',
          '  block_public_policy     = true',
          '  ignore_public_acls      = true',
          '  restrict_public_buckets = true',
          '}',
          ''
        );
      }
      break;
    }
    case 'serverless': {
      const config = resource.config as unknown as ServerlessConfig;
      const runtimeMap: Record<string, string> = {
        nodejs20: 'nodejs20.x',
        nodejs18: 'nodejs18.x',
        python312: 'python3.12',
        python311: 'python3.11',
        go: 'provided.al2023',
        rust: 'provided.al2023',
        dotnet: 'dotnet8',
      };
      lines.push(
        `# Lambda: ${resource.name}`,
        `resource "aws_lambda_function" "${name}" {`,
        `  function_name = "${projectName}-${resource.name}"`,
        `  runtime       = "${runtimeMap[config.runtime] ?? 'nodejs20.x'}"`,
        '  handler       = "index.handler"',
        `  memory_size   = ${config.memory}`,
        `  timeout       = ${config.timeout}`,
        '',
        '  filename = "lambda.zip"',
        '',
        '  role = aws_iam_role.lambda_role.arn',
        '}',
        '',
        'resource "aws_iam_role" "lambda_role" {',
        `  name = "${projectName}-lambda-role"`,
        '',
        '  assume_role_policy = jsonencode({',
        '    Version = "2012-10-17"',
        '    Statement = [{',
        '      Action = "sts:AssumeRole"',
        '      Effect = "Allow"',
        '      Principal = {',
        '        Service = "lambda.amazonaws.com"',
        '      }',
        '    }]',
        '  })',
        '}',
        ''
      );
      break;
    }
    case 'container': {
      const config = resource.config as unknown as ContainerConfig;
      lines.push(
        `# ECS Service: ${resource.name}`,
        'resource "aws_ecs_cluster" "main" {',
        `  name = "${projectName}-cluster"`,
        '}',
        '',
        `resource "aws_ecs_task_definition" "${name}" {`,
        `  family                   = "${projectName}-${resource.name}"`,
        '  network_mode             = "awsvpc"',
        '  requires_compatibilities = ["FARGATE"]',
        `  cpu                      = ${config.cpu}`,
        `  memory                   = ${config.memory}`,
        '',
        '  container_definitions = jsonencode([{',
        `    name  = "${resource.name}"`,
        `    image = "${config.image}"`,
        `    portMappings = [{`,
        `      containerPort = ${config.port ?? 80}`,
        '      protocol      = "tcp"',
        '    }]',
        '  }])',
        '}',
        ''
      );
      break;
    }
    case 'cache': {
      lines.push(
        `# ElastiCache Redis: ${resource.name}`,
        `resource "aws_elasticache_cluster" "${name}" {`,
        `  cluster_id           = "${projectName}-${resource.name}"`,
        '  engine               = "redis"',
        '  node_type            = "cache.t3.micro"',
        '  num_cache_nodes      = 1',
        '  parameter_group_name = "default.redis7"',
        '}',
        ''
      );
      break;
    }
    case 'queue': {
      lines.push(
        `# SQS Queue: ${resource.name}`,
        `resource "aws_sqs_queue" "${name}" {`,
        `  name                      = "${projectName}-${resource.name}"`,
        '  delay_seconds             = 0',
        '  max_message_size          = 262144',
        '  message_retention_seconds = 345600',
        '  visibility_timeout_seconds = 30',
        '}',
        ''
      );
      break;
    }
    case 'cdn': {
      lines.push(
        `# CloudFront Distribution: ${resource.name}`,
        `resource "aws_cloudfront_distribution" "${name}" {`,
        '  enabled             = true',
        '  is_ipv6_enabled     = true',
        '  default_root_object = "index.html"',
        '',
        '  origin {',
        `    domain_name = aws_s3_bucket.${name}_origin.bucket_regional_domain_name`,
        `    origin_id   = "S3-${projectName}-${resource.name}"`,
        '  }',
        '',
        '  default_cache_behavior {',
        '    allowed_methods  = ["GET", "HEAD"]',
        '    cached_methods   = ["GET", "HEAD"]',
        `    target_origin_id = "S3-${projectName}-${resource.name}"`,
        '',
        '    forwarded_values {',
        '      query_string = false',
        '      cookies {',
        '        forward = "none"',
        '      }',
        '    }',
        '',
        '    viewer_protocol_policy = "redirect-to-https"',
        '  }',
        '',
        '  restrictions {',
        '    geo_restriction {',
        '      restriction_type = "none"',
        '    }',
        '  }',
        '',
        '  viewer_certificate {',
        '    cloudfront_default_certificate = true',
        '  }',
        '}',
        ''
      );
      break;
    }
  }

  return lines;
}

function generateTerraformGCP(spec: InfrastructureSpec): string {
  const lines: string[] = [
    '# Generated by G-Rump Cloud Provisioning',
    '# Terraform configuration for Google Cloud Platform',
    '',
    'terraform {',
    '  required_version = ">= 1.0"',
    '  required_providers {',
    '    google = {',
    '      source  = "hashicorp/google"',
    '      version = "~> 5.0"',
    '    }',
    '  }',
    '}',
    '',
    'variable "project_id" {',
    '  description = "GCP Project ID"',
    '  type        = string',
    '}',
    '',
    'variable "environment" {',
    '  description = "Environment name"',
    '  type        = string',
    '  default     = "production"',
    '}',
    '',
    'provider "google" {',
    '  project = var.project_id',
    `  region  = "${spec.region}"`,
    '}',
    '',
    'locals {',
    '  common_labels = {',
    `    project     = "${spec.name.toLowerCase().replace(/[^a-z0-9-]/g, '-')}"`,
    '    managed_by  = "terraform"',
    '    environment = var.environment',
    ...Object.entries(spec.tags ?? {}).map(([k, v]) => `    ${k.toLowerCase().replace(/[^a-z0-9-]/g, '-')} = "${v.toLowerCase()}"`),
    '  }',
    '}',
    '',
  ];

  // Generate resources
  for (const resource of spec.resources) {
    lines.push(...generateGCPResource(resource, spec.name));
  }

  return lines.join('\n');
}

function generateGCPResource(resource: CloudResource, projectName: string): string[] {
  const lines: string[] = [];
  const name = resource.name.toLowerCase().replace(/[^a-z0-9-]/g, '-');

  switch (resource.type) {
    case 'compute': {
      const config = resource.config as unknown as ComputeConfig;
      const machineType = GCP_MACHINE_TYPES[config.size] ?? 'e2-medium';
      lines.push(
        `# Compute Engine: ${resource.name}`,
        `resource "google_compute_instance" "${name}" {`,
        `  name         = "${projectName}-${name}"`,
        `  machine_type = "${machineType}"`,
        '  zone         = "${var.project_id}-a"',
        '',
        '  boot_disk {',
        '    initialize_params {',
        '      image = "debian-cloud/debian-11"',
        '    }',
        '  }',
        '',
        '  network_interface {',
        '    network = "default"',
        '    access_config {}',
        '  }',
        '',
        '  labels = local.common_labels',
        '}',
        ''
      );
      break;
    }
    case 'database': {
      const config = resource.config as unknown as DatabaseConfig;
      if (config.engine === 'firestore') {
        lines.push(
          `# Firestore Database: ${resource.name}`,
          `resource "google_firestore_database" "${name}" {`,
          `  name        = "${name}"`,
          '  location_id = var.project_id',
          '  type        = "FIRESTORE_NATIVE"',
          '}',
          ''
        );
      } else {
        const tier = GCP_SQL_TIERS[config.size] ?? 'db-g1-small';
        const dbVersion = config.engine === 'postgres' ? 'POSTGRES_15' : 'MYSQL_8_0';
        lines.push(
          `# Cloud SQL: ${resource.name}`,
          `resource "google_sql_database_instance" "${name}" {`,
          `  name             = "${projectName}-${name}"`,
          `  database_version = "${dbVersion}"`,
          '  region           = var.project_id',
          '',
          '  settings {',
          `    tier = "${tier}"`,
          '',
          '    backup_configuration {',
          `      enabled            = ${config.highAvailability ?? true}`,
          `      binary_log_enabled = ${config.engine === 'mysql'}`,
          '    }',
          '',
          `    availability_type = "${config.highAvailability ? 'REGIONAL' : 'ZONAL'}"`,
          '  }',
          '',
          '  deletion_protection = false',
          '}',
          ''
        );
      }
      break;
    }
    case 'storage': {
      const config = resource.config as unknown as StorageConfig;
      const storageClass = config.replication === 'global' ? 'MULTI_REGIONAL' : 
                          config.replication === 'regional' ? 'REGIONAL' : 'STANDARD';
      lines.push(
        `# Cloud Storage: ${resource.name}`,
        `resource "google_storage_bucket" "${name}" {`,
        `  name          = "${projectName}-${name}-\${random_id.bucket_suffix.hex}"`,
        '  location      = var.project_id',
        `  storage_class = "${storageClass}"`,
        '',
        '  versioning {',
        '    enabled = true',
        '  }',
        '',
        `  uniform_bucket_level_access = ${!config.public}`,
        '',
        '  labels = local.common_labels',
        '}',
        ''
      );
      break;
    }
    case 'serverless': {
      const config = resource.config as unknown as ServerlessConfig;
      const runtimeMap: Record<string, string> = {
        nodejs20: 'nodejs20',
        nodejs18: 'nodejs18',
        python312: 'python312',
        python311: 'python311',
        go: 'go121',
        rust: 'go121', // Rust via custom runtime
        dotnet: 'dotnet6',
      };
      lines.push(
        `# Cloud Function: ${resource.name}`,
        `resource "google_cloudfunctions2_function" "${name}" {`,
        `  name     = "${projectName}-${name}"`,
        '  location = var.project_id',
        '',
        '  build_config {',
        `    runtime     = "${runtimeMap[config.runtime] ?? 'nodejs20'}"`,
        '    entry_point = "handler"',
        '    source {',
        '      storage_source {',
        `        bucket = google_storage_bucket.${name}_source.name`,
        '        object = "function.zip"',
        '      }',
        '    }',
        '  }',
        '',
        '  service_config {',
        `    max_instance_count = 10`,
        `    available_memory   = "${config.memory}M"`,
        `    timeout_seconds    = ${config.timeout}`,
        '  }',
        '',
        '  labels = local.common_labels',
        '}',
        ''
      );
      break;
    }
    case 'container': {
      const config = resource.config as unknown as ContainerConfig;
      lines.push(
        `# Cloud Run: ${resource.name}`,
        `resource "google_cloud_run_v2_service" "${name}" {`,
        `  name     = "${projectName}-${name}"`,
        '  location = var.project_id',
        '',
        '  template {',
        '    containers {',
        `      image = "${config.image}"`,
        '      resources {',
        `        limits = {`,
        `          cpu    = "${config.cpu / 1000}"`,
        `          memory = "${config.memory}Mi"`,
        '        }',
        '      }',
        '      ports {',
        `        container_port = ${config.port ?? 8080}`,
        '      }',
        '    }',
        `    scaling {`,
        `      min_instance_count = 0`,
        `      max_instance_count = ${config.replicas ?? 10}`,
        '    }',
        '  }',
        '',
        '  labels = local.common_labels',
        '}',
        ''
      );
      break;
    }
    case 'cache': {
      lines.push(
        `# Memorystore Redis: ${resource.name}`,
        `resource "google_redis_instance" "${name}" {`,
        `  name           = "${projectName}-${name}"`,
        '  tier           = "BASIC"',
        '  memory_size_gb = 1',
        '  region         = var.project_id',
        '',
        '  labels = local.common_labels',
        '}',
        ''
      );
      break;
    }
    case 'queue': {
      lines.push(
        `# Pub/Sub: ${resource.name}`,
        `resource "google_pubsub_topic" "${name}" {`,
        `  name = "${projectName}-${name}"`,
        '',
        '  labels = local.common_labels',
        '}',
        '',
        `resource "google_pubsub_subscription" "${name}_sub" {`,
        `  name  = "${projectName}-${name}-sub"`,
        `  topic = google_pubsub_topic.${name}.name`,
        '',
        '  ack_deadline_seconds = 30',
        '',
        '  labels = local.common_labels',
        '}',
        ''
      );
      break;
    }
  }

  return lines;
}

function generateTerraformAzure(spec: InfrastructureSpec): string {
  const lines: string[] = [
    '# Generated by G-Rump Cloud Provisioning',
    '# Terraform configuration for Microsoft Azure',
    '',
    'terraform {',
    '  required_version = ">= 1.0"',
    '  required_providers {',
    '    azurerm = {',
    '      source  = "hashicorp/azurerm"',
    '      version = "~> 3.0"',
    '    }',
    '  }',
    '}',
    '',
    'provider "azurerm" {',
    '  features {}',
    '}',
    '',
    'variable "environment" {',
    '  description = "Environment name"',
    '  type        = string',
    '  default     = "production"',
    '}',
    '',
    `resource "azurerm_resource_group" "main" {`,
    `  name     = "${spec.name}-rg"`,
    `  location = "${spec.region}"`,
    '',
    '  tags = {',
    `    Project     = "${spec.name}"`,
    '    ManagedBy   = "terraform"',
    '    Environment = var.environment',
    ...Object.entries(spec.tags ?? {}).map(([k, v]) => `    ${k} = "${v}"`),
    '  }',
    '}',
    '',
  ];

  // Generate resources
  for (const resource of spec.resources) {
    lines.push(...generateAzureResource(resource, spec.name));
  }

  return lines.join('\n');
}

function generateAzureResource(resource: CloudResource, projectName: string): string[] {
  const lines: string[] = [];
  const name = resource.name.replace(/[^a-zA-Z0-9]/g, '');

  switch (resource.type) {
    case 'compute': {
      const config = resource.config as unknown as ComputeConfig;
      const vmSize = AZURE_VM_SIZES[config.size] ?? 'Standard_B2s';
      lines.push(
        `# Virtual Machine: ${resource.name}`,
        `resource "azurerm_linux_virtual_machine" "${name}" {`,
        `  name                = "${projectName}-${name}"`,
        '  resource_group_name = azurerm_resource_group.main.name',
        '  location            = azurerm_resource_group.main.location',
        `  size                = "${vmSize}"`,
        '  admin_username      = "adminuser"',
        '',
        '  admin_ssh_key {',
        '    username   = "adminuser"',
        '    public_key = file("~/.ssh/id_rsa.pub")',
        '  }',
        '',
        '  network_interface_ids = [',
        `    azurerm_network_interface.${name}_nic.id,`,
        '  ]',
        '',
        '  os_disk {',
        '    caching              = "ReadWrite"',
        '    storage_account_type = "Standard_LRS"',
        '  }',
        '',
        '  source_image_reference {',
        '    publisher = "Canonical"',
        '    offer     = "0001-com-ubuntu-server-jammy"',
        '    sku       = "22_04-lts"',
        '    version   = "latest"',
        '  }',
        '',
        '  tags = azurerm_resource_group.main.tags',
        '}',
        ''
      );
      break;
    }
    case 'database': {
      const config = resource.config as unknown as DatabaseConfig;
      if (config.engine === 'cosmosdb') {
        lines.push(
          `# Cosmos DB: ${resource.name}`,
          `resource "azurerm_cosmosdb_account" "${name}" {`,
          `  name                = "${projectName}-${name}"`,
          '  location            = azurerm_resource_group.main.location',
          '  resource_group_name = azurerm_resource_group.main.name',
          '  offer_type          = "Standard"',
          '  kind                = "GlobalDocumentDB"',
          '',
          '  consistency_policy {',
          '    consistency_level = "Session"',
          '  }',
          '',
          '  geo_location {',
          '    location          = azurerm_resource_group.main.location',
          '    failover_priority = 0',
          '  }',
          '',
          '  tags = azurerm_resource_group.main.tags',
          '}',
          ''
        );
      } else {
        const sku = AZURE_SQL_SKUS[config.size] ?? 'S0';
        lines.push(
          `# Azure SQL: ${resource.name}`,
          `resource "azurerm_mssql_server" "${name}" {`,
          `  name                         = "${projectName}-${name}"`,
          '  resource_group_name          = azurerm_resource_group.main.name',
          '  location                     = azurerm_resource_group.main.location',
          '  version                      = "12.0"',
          '  administrator_login          = var.sql_admin_login',
          '  administrator_login_password = var.sql_admin_password',
          '',
          '  tags = azurerm_resource_group.main.tags',
          '}',
          '',
          `resource "azurerm_mssql_database" "${name}_db" {`,
          `  name      = "${name}"`,
          `  server_id = azurerm_mssql_server.${name}.id`,
          `  sku_name  = "${sku}"`,
          '',
          '  tags = azurerm_resource_group.main.tags',
          '}',
          ''
        );
      }
      break;
    }
    case 'storage': {
      const config = resource.config as unknown as StorageConfig;
      const replication = config.replication === 'global' ? 'GRS' : 
                         config.replication === 'regional' ? 'ZRS' : 'LRS';
      lines.push(
        `# Storage Account: ${resource.name}`,
        `resource "azurerm_storage_account" "${name}" {`,
        `  name                     = "${projectName.toLowerCase().replace(/[^a-z0-9]/g, '')}${name.toLowerCase()}"`,
        '  resource_group_name      = azurerm_resource_group.main.name',
        '  location                 = azurerm_resource_group.main.location',
        '  account_tier             = "Standard"',
        `  account_replication_type = "${replication}"`,
        '',
        '  tags = azurerm_resource_group.main.tags',
        '}',
        ''
      );
      break;
    }
    case 'serverless': {
      const config = resource.config as unknown as ServerlessConfig;
      lines.push(
        `# Function App: ${resource.name}`,
        `resource "azurerm_linux_function_app" "${name}" {`,
        `  name                = "${projectName}-${name}"`,
        '  resource_group_name = azurerm_resource_group.main.name',
        '  location            = azurerm_resource_group.main.location',
        '',
        `  storage_account_name       = azurerm_storage_account.${name}_storage.name`,
        `  storage_account_access_key = azurerm_storage_account.${name}_storage.primary_access_key`,
        `  service_plan_id            = azurerm_service_plan.${name}_plan.id`,
        '',
        '  site_config {',
        '    application_stack {',
        `      node_version = "20"`,
        '    }',
        '  }',
        '',
        '  tags = azurerm_resource_group.main.tags',
        '}',
        ''
      );
      break;
    }
    case 'container': {
      const config = resource.config as unknown as ContainerConfig;
      lines.push(
        `# Container App: ${resource.name}`,
        `resource "azurerm_container_app" "${name}" {`,
        `  name                         = "${projectName}-${name}"`,
        '  container_app_environment_id = azurerm_container_app_environment.main.id',
        '  resource_group_name          = azurerm_resource_group.main.name',
        '  revision_mode                = "Single"',
        '',
        '  template {',
        '    container {',
        `      name   = "${name}"`,
        `      image  = "${config.image}"`,
        `      cpu    = ${config.cpu / 1000}`,
        `      memory = "${config.memory / 1024}Gi"`,
        '    }',
        '  }',
        '',
        '  tags = azurerm_resource_group.main.tags',
        '}',
        ''
      );
      break;
    }
    case 'cache': {
      lines.push(
        `# Redis Cache: ${resource.name}`,
        `resource "azurerm_redis_cache" "${name}" {`,
        `  name                = "${projectName}-${name}"`,
        '  location            = azurerm_resource_group.main.location',
        '  resource_group_name = azurerm_resource_group.main.name',
        '  capacity            = 0',
        '  family              = "C"',
        '  sku_name            = "Basic"',
        '',
        '  tags = azurerm_resource_group.main.tags',
        '}',
        ''
      );
      break;
    }
    case 'queue': {
      lines.push(
        `# Service Bus Queue: ${resource.name}`,
        `resource "azurerm_servicebus_namespace" "${name}_ns" {`,
        `  name                = "${projectName}-${name}-ns"`,
        '  location            = azurerm_resource_group.main.location',
        '  resource_group_name = azurerm_resource_group.main.name',
        '  sku                 = "Standard"',
        '',
        '  tags = azurerm_resource_group.main.tags',
        '}',
        '',
        `resource "azurerm_servicebus_queue" "${name}" {`,
        `  name         = "${name}"`,
        `  namespace_id = azurerm_servicebus_namespace.${name}_ns.id`,
        '}',
        ''
      );
      break;
    }
  }

  return lines;
}

// ========== Pulumi Generators ==========

function generatePulumi(spec: InfrastructureSpec): string {
  const imports: Set<string> = new Set();
  const resources: string[] = [];

  // Add imports based on provider
  switch (spec.provider) {
    case 'aws':
      imports.add('import * as aws from "@pulumi/aws";');
      break;
    case 'gcp':
      imports.add('import * as gcp from "@pulumi/gcp";');
      break;
    case 'azure':
      imports.add('import * as azure from "@pulumi/azure-native";');
      break;
  }
  imports.add('import * as pulumi from "@pulumi/pulumi";');

  // Generate resources
  for (const resource of spec.resources) {
    const code = generatePulumiResource(resource, spec);
    if (code) {
      resources.push(code);
    }
  }

  return [
    '// Generated by G-Rump Cloud Provisioning',
    `// Pulumi configuration for ${spec.provider.toUpperCase()}`,
    '',
    ...Array.from(imports),
    '',
    `const config = new pulumi.Config();`,
    `const environment = config.get("environment") || "production";`,
    '',
    '// Common tags',
    'const commonTags = {',
    `  Project: "${spec.name}",`,
    '  ManagedBy: "pulumi",',
    '  Environment: environment,',
    ...Object.entries(spec.tags ?? {}).map(([k, v]) => `  ${k}: "${v}",`),
    '};',
    '',
    ...resources,
  ].join('\n');
}

function generatePulumiResource(resource: CloudResource, spec: InfrastructureSpec): string {
  const lines: string[] = [];
  const name = resource.name.replace(/[^a-zA-Z0-9]/g, '');

  switch (spec.provider) {
    case 'aws':
      lines.push(...generatePulumiAWSResource(resource, spec.name, name));
      break;
    case 'gcp':
      lines.push(...generatePulumiGCPResource(resource, spec.name, name));
      break;
    case 'azure':
      lines.push(...generatePulumiAzureResource(resource, spec.name, name));
      break;
  }

  return lines.join('\n');
}

function generatePulumiAWSResource(resource: CloudResource, projectName: string, varName: string): string[] {
  const lines: string[] = [];

  switch (resource.type) {
    case 'storage':
      lines.push(
        `// S3 Bucket: ${resource.name}`,
        `const ${varName}Bucket = new aws.s3.Bucket("${varName}", {`,
        `  bucket: "${projectName}-${resource.name}",`,
        '  tags: commonTags,',
        '});',
        '',
        `export const ${varName}BucketName = ${varName}Bucket.bucket;`,
        ''
      );
      break;
    case 'serverless': {
      const config = resource.config as unknown as ServerlessConfig;
      lines.push(
        `// Lambda: ${resource.name}`,
        `const ${varName}Lambda = new aws.lambda.Function("${varName}", {`,
        `  name: "${projectName}-${resource.name}",`,
        '  runtime: aws.lambda.Runtime.NodeJS20dX,',
        '  handler: "index.handler",',
        `  memorySize: ${config.memory},`,
        `  timeout: ${config.timeout},`,
        '  code: new pulumi.asset.AssetArchive({',
        '    ".": new pulumi.asset.FileArchive("./lambda"),',
        '  }),',
        '  role: lambdaRole.arn,',
        '  tags: commonTags,',
        '});',
        '',
        `export const ${varName}LambdaArn = ${varName}Lambda.arn;`,
        ''
      );
      break;
    }
    case 'database': {
      const config = resource.config as unknown as DatabaseConfig;
      if (config.engine === 'dynamodb') {
        lines.push(
          `// DynamoDB: ${resource.name}`,
          `const ${varName}Table = new aws.dynamodb.Table("${varName}", {`,
          `  name: "${projectName}-${resource.name}",`,
          '  billingMode: "PAY_PER_REQUEST",',
          '  hashKey: "id",',
          '  attributes: [{ name: "id", type: "S" }],',
          '  tags: commonTags,',
          '});',
          '',
          `export const ${varName}TableName = ${varName}Table.name;`,
          ''
        );
      }
      break;
    }
  }

  return lines;
}

function generatePulumiGCPResource(resource: CloudResource, projectName: string, varName: string): string[] {
  const lines: string[] = [];

  switch (resource.type) {
    case 'storage':
      lines.push(
        `// Cloud Storage: ${resource.name}`,
        `const ${varName}Bucket = new gcp.storage.Bucket("${varName}", {`,
        `  name: "${projectName}-${resource.name}",`,
        '  location: "US",',
        '  labels: commonTags,',
        '});',
        '',
        `export const ${varName}BucketName = ${varName}Bucket.name;`,
        ''
      );
      break;
    case 'container': {
      const config = resource.config as unknown as ContainerConfig;
      lines.push(
        `// Cloud Run: ${resource.name}`,
        `const ${varName}Service = new gcp.cloudrun.Service("${varName}", {`,
        `  name: "${projectName}-${resource.name}",`,
        '  location: config.require("region"),',
        '  template: {',
        '    spec: {',
        '      containers: [{',
        `        image: "${config.image}",`,
        '        resources: {',
        '          limits: {',
        `            cpu: "${config.cpu / 1000}",`,
        `            memory: "${config.memory}Mi",`,
        '          },',
        '        },',
        '      }],',
        '    },',
        '  },',
        '});',
        '',
        `export const ${varName}Url = ${varName}Service.statuses[0].url;`,
        ''
      );
      break;
    }
  }

  return lines;
}

function generatePulumiAzureResource(resource: CloudResource, projectName: string, varName: string): string[] {
  const lines: string[] = [];

  switch (resource.type) {
    case 'storage':
      lines.push(
        `// Storage Account: ${resource.name}`,
        `const ${varName}Storage = new azure.storage.StorageAccount("${varName}", {`,
        `  accountName: "${projectName.toLowerCase().replace(/[^a-z0-9]/g, '')}${varName.toLowerCase()}",`,
        '  resourceGroupName: resourceGroup.name,',
        '  location: resourceGroup.location,',
        '  sku: { name: "Standard_LRS" },',
        '  kind: "StorageV2",',
        '  tags: commonTags,',
        '});',
        '',
        `export const ${varName}StorageEndpoint = ${varName}Storage.primaryEndpoints;`,
        ''
      );
      break;
  }

  return lines;
}

// ========== Main Generator Functions ==========

/**
 * Generate Infrastructure as Code for a specification
 */
export function generateIaC(spec: InfrastructureSpec, tool: IaCTool = 'terraform'): GeneratedIaC {
  const files: GeneratedIaC['files'] = [];
  let mainContent: string;

  if (tool === 'terraform') {
    switch (spec.provider) {
      case 'aws':
        mainContent = generateTerraformAWS(spec);
        break;
      case 'gcp':
        mainContent = generateTerraformGCP(spec);
        break;
      case 'azure':
        mainContent = generateTerraformAzure(spec);
        break;
      default:
        mainContent = generateTerraformAWS(spec);
    }

    files.push(
      { name: 'main.tf', content: mainContent },
      { name: 'outputs.tf', content: generateTerraformOutputs(spec) },
      { name: 'variables.tf', content: generateTerraformVariables(spec) },
      { name: 'terraform.tfvars.example', content: generateTerraformTfvars(spec) }
    );
  } else {
    mainContent = generatePulumi(spec);
    files.push(
      { name: 'index.ts', content: mainContent },
      { name: 'Pulumi.yaml', content: generatePulumiYaml(spec) },
      { name: 'Pulumi.dev.yaml', content: generatePulumiStackConfig(spec) }
    );
  }

  const commands = tool === 'terraform'
    ? [
        'terraform init',
        'terraform plan',
        'terraform apply',
      ]
    : [
        'npm install',
        'pulumi up',
      ];

  logger.info({ provider: spec.provider, tool, resourceCount: spec.resources.length }, 'IaC generated');

  return {
    tool,
    provider: spec.provider,
    files,
    commands,
    estimatedCostPerMonth: estimateMonthlyCost(spec),
  };
}

function generateTerraformOutputs(spec: InfrastructureSpec): string {
  const lines: string[] = [
    '# Terraform Outputs',
    '',
  ];

  for (const resource of spec.resources) {
    const name = resource.name.replace(/[^a-zA-Z0-9]/g, '_');
    switch (resource.type) {
      case 'storage':
        lines.push(
          `output "${name}_bucket" {`,
          `  description = "Storage bucket for ${resource.name}"`,
          spec.provider === 'aws' ? `  value       = aws_s3_bucket.${name}.bucket` :
          spec.provider === 'gcp' ? `  value       = google_storage_bucket.${name}.name` :
          `  value       = azurerm_storage_account.${name}.primary_blob_endpoint`,
          '}',
          ''
        );
        break;
      case 'database':
        lines.push(
          `output "${name}_endpoint" {`,
          `  description = "Database endpoint for ${resource.name}"`,
          spec.provider === 'aws' ? `  value       = aws_db_instance.${name}.endpoint` :
          spec.provider === 'gcp' ? `  value       = google_sql_database_instance.${name}.connection_name` :
          `  value       = azurerm_mssql_server.${name}.fully_qualified_domain_name`,
          '  sensitive   = true',
          '}',
          ''
        );
        break;
    }
  }

  return lines.join('\n');
}

function generateTerraformVariables(spec: InfrastructureSpec): string {
  const lines: string[] = [
    '# Terraform Variables',
    '',
    'variable "environment" {',
    '  description = "Deployment environment"',
    '  type        = string',
    '  default     = "production"',
    '}',
    '',
    'variable "region" {',
    '  description = "Cloud region"',
    '  type        = string',
    `  default     = "${spec.region}"`,
    '}',
    '',
  ];

  // Add provider-specific variables
  if (spec.provider === 'gcp') {
    lines.push(
      'variable "project_id" {',
      '  description = "GCP Project ID"',
      '  type        = string',
      '}',
      ''
    );
  }

  return lines.join('\n');
}

function generateTerraformTfvars(spec: InfrastructureSpec): string {
  const lines: string[] = [
    '# Example terraform.tfvars',
    '# Copy this file to terraform.tfvars and fill in your values',
    '',
    'environment = "production"',
    `region      = "${spec.region}"`,
    '',
  ];

  if (spec.provider === 'gcp') {
    lines.push('project_id  = "your-gcp-project-id"');
  }

  return lines.join('\n');
}

function generatePulumiYaml(spec: InfrastructureSpec): string {
  return [
    `name: ${spec.name}`,
    'runtime: nodejs',
    `description: Infrastructure for ${spec.name}`,
    '',
  ].join('\n');
}

function generatePulumiStackConfig(spec: InfrastructureSpec): string {
  const config: Record<string, string> = {
    [`${spec.provider}:region`]: spec.region,
  };

  if (spec.provider === 'gcp') {
    config['gcp:project'] = 'your-project-id';
  }

  return [
    'config:',
    ...Object.entries(config).map(([k, v]) => `  ${k}: ${v}`),
    '',
  ].join('\n');
}

function estimateMonthlyCost(spec: InfrastructureSpec): number {
  let total = 0;

  for (const resource of spec.resources) {
  switch (resource.type) {
    case 'compute': {
      const config = resource.config as unknown as ComputeConfig;
        const baseCosts: Record<string, number> = { small: 15, medium: 30, large: 60, xlarge: 120 };
        total += (baseCosts[config.size] ?? 30) * (config.count ?? 1);
        break;
      }
      case 'database': {
        const config = resource.config as unknown as DatabaseConfig;
        const baseCosts: Record<string, number> = { small: 15, medium: 50, large: 150 };
        total += baseCosts[config.size] ?? 50;
        if (config.highAvailability) total *= 2;
        break;
      }
      case 'storage': {
        const config = resource.config as unknown as StorageConfig;
        total += (config.size / 1000) * 23; // ~$23/TB/month
        break;
      }
      case 'serverless':
        total += 5; // Minimal base cost
        break;
      case 'container': {
        const config = resource.config as unknown as ContainerConfig;
        total += (config.cpu / 1000) * 30 * (config.replicas ?? 1);
        break;
      }
      case 'cache':
        total += 15;
        break;
      case 'queue':
        total += 5;
        break;
      case 'cdn':
        total += 10;
        break;
    }
  }

  return Math.round(total);
}

// ========== Quick Templates ==========

/**
 * Generate a simple web app infrastructure
 */
export function generateWebAppTemplate(
  name: string,
  provider: CloudProvider,
  region: string
): InfrastructureSpec {
  return {
    name,
    provider,
    region,
    resources: [
      {
        type: 'container',
        name: 'web',
        provider,
        config: {
          image: 'nginx:latest',
          cpu: 256,
          memory: 512,
          replicas: 2,
          port: 80,
        } as ContainerConfig,
      },
      {
        type: 'database',
        name: 'db',
        provider,
        config: {
          engine: 'postgres',
          size: 'small',
          highAvailability: false,
        } as DatabaseConfig,
      },
      {
        type: 'cache',
        name: 'cache',
        provider,
        config: {},
      },
      {
        type: 'storage',
        name: 'assets',
        provider,
        config: {
          type: 'object',
          size: 10,
          public: true,
        } as StorageConfig,
      },
    ],
    tags: {
      Application: name,
      Type: 'WebApp',
    },
  };
}

/**
 * Generate a serverless API infrastructure
 */
export function generateServerlessApiTemplate(
  name: string,
  provider: CloudProvider,
  region: string
): InfrastructureSpec {
  return {
    name,
    provider,
    region,
    resources: [
      {
        type: 'serverless',
        name: 'api',
        provider,
        config: {
          runtime: 'nodejs20',
          memory: 256,
          timeout: 30,
          triggers: ['http'],
        } as ServerlessConfig,
      },
      {
        type: 'database',
        name: 'data',
        provider,
        config: {
          engine: provider === 'aws' ? 'dynamodb' : provider === 'gcp' ? 'firestore' : 'cosmosdb',
          size: 'small',
        } as DatabaseConfig,
      },
      {
        type: 'storage',
        name: 'uploads',
        provider,
        config: {
          type: 'object',
          size: 50,
          public: false,
        } as StorageConfig,
      },
    ],
    tags: {
      Application: name,
      Type: 'ServerlessAPI',
    },
  };
}

/**
 * Generate a microservices infrastructure
 */
export function generateMicroservicesTemplate(
  name: string,
  provider: CloudProvider,
  region: string,
  services: string[]
): InfrastructureSpec {
  return {
    name,
    provider,
    region,
    resources: [
      ...services.map((svc) => ({
        type: 'container' as ResourceType,
        name: svc,
        provider,
        config: {
          image: `${name}/${svc}:latest`,
          cpu: 256,
          memory: 512,
          replicas: 2,
          port: 8080,
        } as ContainerConfig,
      })),
      {
        type: 'database',
        name: 'shared-db',
        provider,
        config: {
          engine: 'postgres',
          size: 'medium',
          highAvailability: true,
        } as DatabaseConfig,
      },
      {
        type: 'cache',
        name: 'shared-cache',
        provider,
        config: {},
      },
      {
        type: 'queue',
        name: 'events',
        provider,
        config: {},
      },
    ],
    networking: {
      vpcCidr: '10.0.0.0/16',
      publicSubnets: true,
      privateSubnets: true,
      natGateway: true,
    },
    tags: {
      Application: name,
      Type: 'Microservices',
    },
  };
}
