/**
 * User Skills Service
 * CRUD for G-Agent self-created skills stored in backend/data/user-skills/
 */

import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { skillRegistry } from '../../skills/index.js';
import { writeAuditLog } from '../security/auditLogService.js';
import { checkInput } from '../security/guardrailsService.js';
import type { SkillManifest } from '../../skills/types.js';
import logger from '../../middleware/logger.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export const USER_SKILLS_DIR = path.resolve(process.cwd(), 'data', 'user-skills');

/** Sanitize skill ID (alphanumeric, hyphens only) */
function sanitizeSkillId(name: string): string {
  return (
    name
      .toLowerCase()
      .replace(/[^a-z0-9-]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '') || 'skill'
  );
}

/** Default manifest for new skills */
function defaultManifest(
  id: string,
  name: string,
  description: string,
  tools: Array<{ name: string; description: string }> = []
): SkillManifest {
  return {
    id: `user-${id}`,
    name,
    version: '1.0.0',
    description,
    author: 'G-Agent',
    category: 'custom',
    icon: 'wrench',
    tags: ['user-created', 'g-agent'],
    capabilities: {
      providesTools: tools.length > 0,
      providesRoutes: false,
      providesPrompts: false,
      requiresWorkspace: true,
      supportsStreaming: false,
      supportsBackground: false,
    },
    permissions: ['file_read', 'file_write', 'bash_execute'],
    triggers: {
      keywords: [name.toLowerCase()],
      commands: [`/${id}`],
    },
  };
}

/** Ensure user-skills directory exists */
export async function ensureUserSkillsDir(): Promise<void> {
  await fs.mkdir(USER_SKILLS_DIR, { recursive: true });
}

/**
 * Create a new user skill
 */
export async function createSkill(
  name: string,
  description: string,
  tools: Array<{ name: string; description: string }> = [],
  prompts: Record<string, string> = {},
  userId: string = 'default'
): Promise<{ success: boolean; skillId?: string; error?: string }> {
  const contentToCheck = `${name} ${description} ${JSON.stringify(tools)} ${JSON.stringify(prompts)}`;
  const guardResult = await checkInput(contentToCheck, userId);
  if (!guardResult.passed) {
    return { success: false, error: 'Content blocked by guardrails' };
  }

  const id = sanitizeSkillId(name);
  const skillId = `user-${id}`;
  const skillPath = path.join(USER_SKILLS_DIR, id);

  try {
    await ensureUserSkillsDir();
    const existing = await fs
      .access(skillPath)
      .then(() => true)
      .catch(() => false);
    if (existing) {
      return {
        success: false,
        error: `Skill ${id} already exists. Use skill_edit to update.`,
      };
    }

    await fs.mkdir(skillPath, { recursive: true });

    const manifest = defaultManifest(id, name, description, tools);
    await fs.writeFile(
      path.join(skillPath, 'manifest.json'),
      JSON.stringify(manifest, null, 2),
      'utf-8'
    );

    const indexContent = `/**
 * User skill: ${name}
 * Auto-generated by G-Agent
 */
import { readFileSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
const __dirname = dirname(fileURLToPath(import.meta.url));
const manifest = JSON.parse(readFileSync(join(__dirname, 'manifest.json'), 'utf-8'));

export default {
  manifest,
  async run(input, context) {
    return {
      success: true,
      output: \`Skill "${name}" executed. Input: \${JSON.stringify(input)}\`,
      events: [],
      duration: 0,
    };
  },
};
`;
    await fs.writeFile(path.join(skillPath, 'index.js'), indexContent, 'utf-8');

    if (Object.keys(prompts).length > 0) {
      await fs.writeFile(
        path.join(skillPath, 'prompts.json'),
        JSON.stringify(prompts, null, 2),
        'utf-8'
      );
    }

    await skillRegistry.discoverSkills(USER_SKILLS_DIR);
    await writeAuditLog({
      userId,
      action: 'skill_create',
      category: 'skill',
      target: skillId,
      metadata: { name, path: skillPath },
    });

    logger.info({ skillId, name, userId }, 'User skill created');
    return { success: true, skillId };
  } catch (err) {
    logger.error({ err, skillId, name }, 'Failed to create user skill');
    return {
      success: false,
      error: (err as Error).message,
    };
  }
}

/**
 * Edit an existing user skill
 */
export async function editSkill(
  skillId: string,
  updates: Partial<{
    name: string;
    description: string;
    tools: unknown[];
    prompts: Record<string, string>;
  }>,
  userId: string = 'default'
): Promise<{ success: boolean; error?: string }> {
  const contentToCheck = JSON.stringify(updates);
  const guardResult = await checkInput(contentToCheck, userId);
  if (!guardResult.passed) {
    return { success: false, error: 'Content blocked by guardrails' };
  }

  const id = skillId.startsWith('user-') ? skillId.slice(5) : skillId;
  const skillPath = path.join(USER_SKILLS_DIR, id);

  try {
    const manifestPath = path.join(skillPath, 'manifest.json');
    await fs.access(manifestPath);
    const manifestContent = await fs.readFile(manifestPath, 'utf-8');
    const manifest = JSON.parse(manifestContent) as SkillManifest;

    if (updates.name) manifest.name = updates.name;
    if (updates.description) manifest.description = updates.description;

    await fs.writeFile(manifestPath, JSON.stringify(manifest, null, 2), 'utf-8');

    if (updates.prompts) {
      await fs.writeFile(
        path.join(skillPath, 'prompts.json'),
        JSON.stringify(updates.prompts, null, 2),
        'utf-8'
      );
    }

    await skillRegistry.discoverSkills(USER_SKILLS_DIR);
    await writeAuditLog({
      userId,
      action: 'skill_edit',
      category: 'skill',
      target: skillId,
      metadata: { updates: Object.keys(updates) },
    });

    logger.info({ skillId, userId }, 'User skill edited');
    return { success: true };
  } catch (err) {
    if ((err as NodeJS.ErrnoException).code === 'ENOENT') {
      return { success: false, error: `Skill ${skillId} not found` };
    }
    logger.error({ err, skillId }, 'Failed to edit user skill');
    return { success: false, error: (err as Error).message };
  }
}

/**
 * Run a skill test (execute with sample input)
 */
export async function runSkillTest(
  skillId: string,
  input: Record<string, unknown>,
  workspaceRoot?: string,
  _userId: string = 'default'
): Promise<{
  success: boolean;
  output?: string;
  error?: string;
  duration?: number;
}> {
  const skill = skillRegistry.getSkill(skillId);
  if (!skill) {
    return { success: false, error: `Skill ${skillId} not found` };
  }

  try {
    const { createSkillContext } = await import('../../skills/base/SkillContext.js');
    const context = createSkillContext({
      workspacePath: workspaceRoot,
      source: 'skill_test',
    });
    const start = Date.now();
    const execInput = {
      message: JSON.stringify(input),
      params: input,
    };
    const result = skill.run
      ? await skill.run(execInput, context)
      : {
          success: false,
          output: '',
          events: [],
          duration: 0,
          error: new Error('No run method'),
        };
    const duration = Date.now() - start;
    return {
      success: result.success,
      output: result.output,
      error: result.error?.message,
      duration,
    };
  } catch (err) {
    logger.error({ err, skillId }, 'Skill test failed');
    return {
      success: false,
      error: (err as Error).message,
    };
  }
}

/**
 * List all skills (built-in + user)
 */
export async function listSkills(): Promise<
  Array<{
    id: string;
    name: string;
    version: string;
    description?: string;
    isUser?: boolean;
  }>
> {
  const skills = skillRegistry.getAllSkills();
  return skills.map((s) => ({
    id: s.manifest.id,
    name: s.manifest.name,
    version: s.manifest.version,
    description: s.manifest.description,
    isUser: s.manifest.id.startsWith('user-'),
  }));
}
