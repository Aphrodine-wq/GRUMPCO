import chalk from 'chalk';
import { branding } from '../branding.js';

/**
 * grump bug - Generate creative bug descriptions
 * Because every bug needs a good story
 */

const bugPrefixes = [
  "Intermittent",
  "Heisen",
  "Schr√∂dinger's",
  "Phantom",
  "Quantum",
  "Legacy",
  "Race Condition",
  "Memory Leak",
  "Undefined Behavior",
  "Edge Case"
];

const bugNouns = [
  "Glitch",
  "Anomaly",
  "Curse",
  "Gremlin",
  "Poltergeist",
  "Phenomenon",
  "Specter",
  "Entity",
  "Abomination",
  "Misfeature"
];

const bugDescriptions = [
  "Only manifests during full moons or when Mercury is in retrograde.",
  "Cannot be reproduced in any environment except production.",
  "Disappears when you add console.log statements.",
  "Works perfectly when you demo it to stakeholders.",
  "Only affects users whose names start with 'J'.",
  "Occurs exactly every 4,294,967,295 operations.",
  "Only visible to the colorblind.",
  "Triggered by specific CPU temperatures.",
  "Exists in superposition until observed.",
  "Only happens when the user blinks at 60Hz."
];

const bugSeverities = [
  { level: "Cosmetic", impact: "Makes the UI slightly ugly. Nobody cares.", emoji: "üíÖ" },
  { level: "Minor", impact: "Annoying but livable. Like a mosquito.", emoji: "ü¶ü" },
  { level: "Major", impact: "Breaks important stuff. Coffee required.", emoji: "‚òï" },
  { level: "Critical", impact: "Production is on fire. Run.", emoji: "üî•" },
  { level: "Apocalyptic", impact: "The singularity has begun. Pray.", emoji: "‚òÑÔ∏è" },
  { level: "Existential", impact: "Questions the meaning of code.", emoji: "ü§Ø" }
];

const bugOrigins = [
  "Spawned from the depths of legacy code, untouched since 2015.",
  "Birthed during a 3 AM caffeine-fueled coding session.",
  "Manifested when someone said 'just a quick fix'.",
  "Created by the intern who 'totally tested it'.",
  "Emerged from a copy-paste from StackOverflow.",
  "Generated by an AI code assistant having a bad day.",
  "Formed when two 'temporary' solutions had a baby.",
  "Originated from a misunderstood requirements document.",
  "Born from a merge conflict that was 'handled'.",
  "Created by the ghost of developers past."
];

const fixStrategies = [
  { strategy: "Turn it off and on again", success: "30%", effort: "Minimal" },
  { strategy: "Add more console.logs", success: "0% (it's Heisenbug)", effort: "Infinite" },
  { strategy: "Sacrifice a rubber duck", success: "Unknown", effort: "One duck" },
  { strategy: "Rewrite from scratch", success: "Creates 3 new bugs", effort: "Weeks" },
  { strategy: "Blame hardware", success: "80% (politically)", effort: "None" },
  { strategy: "Document as feature", success: "100% (if brave)", effort: "Documentation" },
  { strategy: "Ask on StackOverflow", success: "50% (question closed)", effort: "Hours" },
  { strategy: "Accept and move on", success: "100% (to therapy)", effort: "Emotional" }
];

const bugReports = [
  "Steps to reproduce: 1. Be unlucky. 2. Try to use the app.",
  "Expected behavior: It works. Actual behavior: It doesn't.",
  "Environment: Production (obviously).",
  "Frequency: Only when important people are watching.",
  "Impact: Existential dread for the development team.",
  "Workaround: Don't use that feature. Ever.",
  "Priority: Urgent (but we'll fix it next quarter).",
  "Assigned to: The void (nobody wants it)."
];

interface BugOptions {
  severity?: 'cosmetic' | 'minor' | 'major' | 'critical' | 'apocalyptic';
  count?: number;
  creative?: boolean;
}

export async function execute(options: BugOptions = {}): Promise<void> {
  console.log(branding.getLogo('sassy'));
  console.log(branding.format('\n  üêõ THE G-RUMP BUG GENERATOR üêõ\n', 'title'));
  
  const severity = options.severity;
  const count = Math.min(options.count || 3, 6);
  const creative = options.creative || false;

  console.log(chalk.hex(branding.colors.mediumPurple)(`\n  Mode: ${creative ? 'MAXIMUM CREATIVITY' : 'Standard Chaos'}`));
  console.log(severity ? chalk.hex(branding.colors.lightPurple)(`  Severity Filter: ${severity.toUpperCase()}`) : '');
  console.log(branding.getThinDivider());

  console.log(chalk.hex(branding.colors.mediumPurple)(`\n  üé≤ GENERATING BUG REPORTS:\n`));

  // Generate bugs
  for (let i = 0; i < count; i++) {
    const prefix = bugPrefixes[Math.floor(Math.random() * bugPrefixes.length)];
    const noun = bugNouns[Math.floor(Math.random() * bugNouns.length)];
    const description = bugDescriptions[Math.floor(Math.random() * bugDescriptions.length)];
    const origin = bugOrigins[Math.floor(Math.random() * bugOrigins.length)];
    
    let sevIndex = severity ? 
      bugSeverities.findIndex(s => s.level.toLowerCase() === severity) : 
      Math.floor(Math.random() * bugSeverities.length);
    if (sevIndex === -1) sevIndex = Math.floor(Math.random() * bugSeverities.length);
    const sev = bugSeverities[sevIndex];

    const bugId = `BUG-${Math.floor(Math.random() * 9000) + 1000}`;

    await delay(500);
    
    console.log(chalk.hex(branding.colors.mediumPurple)(`\n  ${sev.emoji} ${bugId}: ${prefix} ${noun}`));
    console.log(chalk.hex(branding.colors.lightPurple)(`  Severity: ${sev.level}`));
    console.log(chalk.hex(branding.colors.white)(`  Impact: ${sev.impact}`));
    console.log(chalk.hex(branding.colors.lightPurple)(`  Description: ${description}`));
    console.log(chalk.hex(branding.colors.mediumPurple)(`  Origin Story: ${origin}`));

    if (creative) {
      const report = bugReports[Math.floor(Math.random() * bugReports.length)];
      console.log(chalk.hex(branding.colors.white)(`  Notes: ${report}`));
    }
  }

  // Fix strategies
  console.log('\n' + branding.getDivider());
  console.log(chalk.hex(branding.colors.mediumPurple)('\n  üîß RECOMMENDED FIX STRATEGIES:\n'));
  
  const strategies = fixStrategies.sort(() => 0.5 - Math.random()).slice(0, 4);
  strategies.forEach((strat, i) => {
    const emoji = ['üéØ', 'üî®', 'üßô', 'üèÉ'][i];
    console.log(chalk.hex(branding.colors.lightPurple)(`  ${emoji} ${strat.strategy}`));
    console.log(chalk.hex(branding.colors.white)(`     Success Rate: ${strat.success} | Effort: ${strat.effort}`));
  });

  // Bug lifecycle
  console.log('\n' + branding.getDivider());
  console.log(chalk.hex(branding.colors.mediumPurple)('\n  üîÑ BUG LIFECYCLE PREDICTION:\n'));
  
  const lifecycle = [
    { stage: "Discovery", duration: "Immediate panic", emoji: "üò±" },
    { stage: "Denial", duration: "2 hours", emoji: "üôÖ" },
    { stage: "Investigation", duration: "3-5 business days", emoji: "üîç" },
    { stage: "Temporary Fix", duration: "15 minutes", emoji: "ü©π" },
    { stage: "Regression", duration: "Next sprint", emoji: "üí•" },
    { stage: "Acceptance", duration: "Eternal", emoji: "ü´†" }
  ];

  lifecycle.forEach(stage => {
    console.log(chalk.hex(branding.colors.lightPurple)(`  ${stage.emoji} ${stage.stage}: ${stage.duration}`));
  });

  // Bug naming ceremony
  console.log('\n' + branding.getDivider());
  console.log(chalk.hex(branding.colors.mediumPurple)('\n  üé® BUG NAMING CEREMONY:\n'));
  
  const ceremonialNames = [
    "The Poltergeist of Production",
    "Heisenberg's Uncertainty Bug",
    "The Phantom of the Opera...ting System",
    "Schr√∂dinger's Feature",
    "The Ghost in the Machine",
    "The Curse of Legacy Code",
    "The Infinite Recursion Demon",
    "The Memory Leak Leviathan"
  ];
  
  const chosenName = ceremonialNames[Math.floor(Math.random() * ceremonialNames.length)];
  console.log(chalk.hex(branding.colors.white)(`  Your bug shall be known as:`));
  console.log(chalk.hex(branding.colors.lightPurple)(`  "${chosenName}"`));
  console.log(chalk.hex(branding.colors.mediumPurple)(`  May its memory haunt future retrospectives.`));

  // Developer coping guide
  console.log('\n' + branding.getDivider());
  console.log(chalk.hex(branding.colors.mediumPurple)('\n  üÜò DEVELOPER COPING GUIDE:\n'));
  
  const coping = [
    "Remember: It's not personal. The code hates everyone equally.",
    "Take breaks. Staring won't fix it, but rest might help you.",
    "Rubber duck debugging works because the duck never judges.",
    "If you can't fix it, feature-flag it into oblivion.",
    "Some bugs are friends we made along the way. Annoying friends.",
    "Documentation is just confessing your bugs in writing."
  ];

  coping.forEach((tip, i) => {
    console.log(chalk.hex(branding.colors.white)(`  ${i + 1}. ${tip}`));
  });

  // Closing
  console.log('\n' + branding.getDivider());
  console.log(branding.format(`\n  ${branding.getSass()}\n`, 'sassy'));
  console.log(branding.status('Bug report generated. May your debugging be swift and your coffee strong.', 'sassy'));
  
  // Easter egg
  if (Math.random() > 0.85) {
    console.log(chalk.hex(branding.colors.lightPurple)(`\n  üíú Remember: The only bug-free code is the code nobody uses.`));
  }
}

function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

export const bugCommand = { execute };
